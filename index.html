<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hockey Board PWA</title>
    
    <link rel="manifest" href="manifest.json">
    
    <script src="konva.min.js"></script>

    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #222;
            touch-action: none;
            font-family: sans-serif;
            -webkit-tap-highlight-color: transparent; 
        }
        #container {
            width: 100vw;
            height: 100vh;
            background-color: #222;
        }
        #toolbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            flex-wrap: wrap; 
            justify-content: center;
            width: auto; 
            min-width: 280px;
            z-index: 100;
        }
        button {
            padding: 10px 14px;
            font-size: 13px;
            font-weight: bold;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: white;
            color: #333;
            cursor: pointer;
            flex-shrink: 0;
        }
        button.active {
            background-color: #007bff;
            color: white;
            border-color: #007bff;
            box-shadow: 0 2px 4px rgba(0,123,255,0.3);
        }
        button#clear-btn {
            color: #d9534f;
            border-color: #d9534f;
        }
        /* ç¸¦å‘ãè­¦å‘Š */
        #portrait-warning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            z-index: 9999;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            text-align: center;
            font-size: 18px;
            padding: 20px;
        }
        @media (orientation: portrait) {
            #portrait-warning { display: flex; }
        }
    </style>
</head>
<body>

    <div id="portrait-warning">
        <p>âš ï¸ ç”»é¢ã‚’æ¨ªå‘ãã«ã—ã¦ãã ã•ã„ âš ï¸</p>
        <p>Please rotate your device</p>
    </div>

    <div id="container"></div>

    <div id="toolbar">
        <button id="mode-drag" class="active">âœ‹ ç§»å‹•</button>
        <button id="mode-pen">ğŸ–Šï¸ ãƒšãƒ³</button>
        <button id="mode-eraser">ğŸ§½ æ¶ˆã—ã‚´ãƒ </button>
        <button id="clear-btn">å…¨æ¶ˆå»</button>
    </div>

    <script>
        // --- 1. ã‚µã‚¤ã‚ºè¨ˆç®— (ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ) ---
        const width = window.innerWidth;
        const height = window.innerHeight;
        const baseSize = Math.min(width, height);
        
        const SIZES = {
            lineThick: baseSize * 0.006,    
            lineThin: baseSize * 0.003,     
            playerRadius: baseSize * 0.028, 
            puckRadius: baseSize * 0.015,   
            fontSize: baseSize * 0.022,     
            benchTop: height * 0.1,         
            toolbarArea: height * 0.15      
        };

        const stage = new Konva.Stage({
            container: 'container',
            width: width,
            height: height,
        });

        Konva.hitOnDragEnabled = true;

        const backgroundLayer = new Konva.Layer();
        const drawingLayer = new Konva.Layer();
        const playerLayer = new Konva.Layer(); 
        
        stage.add(backgroundLayer);
        stage.add(drawingLayer);
        stage.add(playerLayer);


        // --- 2. ãƒªãƒ³ã‚¯æç”» ---
        const padding = 10;
        const rinkWidth = width - (padding * 2);
        const rinkHeight = height - SIZES.benchTop - SIZES.toolbarArea - padding;
        const startX = padding;
        const startY = SIZES.benchTop + padding; 

        // æ°·
        const ice = new Konva.Rect({
            x: startX, y: startY,
            width: rinkWidth, height: rinkHeight,
            fill: 'white',
            stroke: 'black',
            strokeWidth: SIZES.lineThick,
            cornerRadius: rinkHeight * 0.12,
            listening: false 
        });
        backgroundLayer.add(ice);

        const rinkGroup = new Konva.Group({
            clipFunc: function(ctx) {
                ctx.roundRect(startX, startY, rinkWidth, rinkHeight, rinkHeight * 0.12);
            },
            listening: false 
        });
        backgroundLayer.add(rinkGroup);

        // ãƒ©ã‚¤ãƒ³
        rinkGroup.add(new Konva.Line({
            points: [startX + rinkWidth / 2, startY, startX + rinkWidth / 2, startY + rinkHeight],
            stroke: '#C8102E', strokeWidth: SIZES.lineThick
        }));

        const zoneWidth = rinkWidth / 3;
        rinkGroup.add(new Konva.Line({
            points: [startX + zoneWidth, startY, startX + zoneWidth, startY + rinkHeight],
            stroke: '#0033A0', strokeWidth: SIZES.lineThick
        }));
        rinkGroup.add(new Konva.Line({
            points: [startX + rinkWidth - zoneWidth, startY, startX + rinkWidth - zoneWidth, startY + rinkHeight],
            stroke: '#0033A0', strokeWidth: SIZES.lineThick
        }));

        const goalDist = rinkWidth * 0.05;
        rinkGroup.add(new Konva.Line({
            points: [startX + goalDist, startY, startX + goalDist, startY + rinkHeight],
            stroke: '#C8102E', strokeWidth: SIZES.lineThin
        }));
        rinkGroup.add(new Konva.Line({
            points: [startX + rinkWidth - goalDist, startY, startX + rinkWidth - goalDist, startY + rinkHeight],
            stroke: '#C8102E', strokeWidth: SIZES.lineThin
        }));

        // ã‚µãƒ¼ã‚¯ãƒ«
        rinkGroup.add(new Konva.Circle({
            x: startX + rinkWidth / 2,
            y: startY + rinkHeight / 2,
            radius: rinkHeight * 0.15,
            stroke: '#0033A0', strokeWidth: SIZES.lineThin
        }));
        rinkGroup.add(new Konva.Circle({
            x: startX + rinkWidth / 2,
            y: startY + rinkHeight / 2,
            radius: SIZES.lineThin * 1.5, fill: '#0033A0'
        }));

        function drawFaceoffCircle(cx, cy) {
            rinkGroup.add(new Konva.Circle({
                x: cx, y: cy,
                radius: rinkHeight * 0.15,
                stroke: '#C8102E', strokeWidth: SIZES.lineThin
            }));
            rinkGroup.add(new Konva.Circle({
                x: cx, y: cy,
                radius: SIZES.lineThin * 1.5, fill: '#C8102E'
            }));
        }

        const circleX_Left = startX + zoneWidth * 0.55;
        const circleX_Right = startX + rinkWidth - (zoneWidth * 0.55);
        const circleY_Top = startY + rinkHeight * 0.25;
        const circleY_Bottom = startY + rinkHeight * 0.75;

        drawFaceoffCircle(circleX_Left, circleY_Top);
        drawFaceoffCircle(circleX_Left, circleY_Bottom);
        drawFaceoffCircle(circleX_Right, circleY_Top);
        drawFaceoffCircle(circleX_Right, circleY_Bottom);

        rinkGroup.add(new Konva.Arc({
            x: startX + goalDist,
            y: startY + rinkHeight / 2,
            innerRadius: 0,
            outerRadius: rinkHeight * 0.06,
            angle: 180,
            rotation: -90,
            fill: '#41b6e6', opacity: 0.5
        }));
        rinkGroup.add(new Konva.Arc({
            x: startX + rinkWidth - goalDist,
            y: startY + rinkHeight / 2,
            innerRadius: 0,
            outerRadius: rinkHeight * 0.06,
            angle: 180,
            rotation: 90,
            fill: '#41b6e6', opacity: 0.5
        }));


        // --- 3. é¸æ‰‹ãƒ»ãƒ¬ãƒ•ã‚§ãƒªãƒ¼ (ã‚­ãƒ£ãƒƒã‚·ãƒ¥å¯¾å¿œ) ---
        function addPlayer(x, y, color, label) {
            const group = new Konva.Group({
                x: x, y: y,
                draggable: true,
            });

            const r = SIZES.playerRadius;

            const circle = new Konva.Circle({
                radius: r,
                fill: color,
                stroke: 'white',
                strokeWidth: 2,
                shadowColor: 'black',
                shadowBlur: 3,
                shadowOffset: {x: 1, y: 1},
                shadowOpacity: 0.5
            });

            const text = new Konva.Text({
                text: label,
                fontSize: SIZES.fontSize,
                fill: 'white',
                fontStyle: 'bold',
                align: 'center',
                verticalAlign: 'middle',
                offsetX: SIZES.fontSize * 0.7, 
                offsetY: SIZES.fontSize * 0.45,
            });

            group.add(circle);
            group.add(text);
            
            group.on('mouseenter', () => stage.container().style.cursor = 'pointer');
            group.on('mouseleave', () => stage.container().style.cursor = 'default');

            playerLayer.add(group);

            const cacheSize = r * 2 + 10;
            group.cache({
                pixelRatio: 3,
                x: -r - 5, y: -r - 5, width: cacheSize, height: cacheSize
            });
        }

        // --- ãƒ‘ãƒƒã‚¯ ---
        function addPuck(x, y) {
            const group = new Konva.Group({
                x: x, y: y,
                draggable: true,
            });

            const r = SIZES.puckRadius;

            const puck = new Konva.Circle({
                radius: r,
                fill: 'black',
                stroke: '#666',
                strokeWidth: 1,
                shadowColor: 'black',
                shadowBlur: 2,
                shadowOffset: {x: 2, y: 2},
                shadowOpacity: 0.5
            });

            group.add(puck);

            group.on('mouseenter', () => stage.container().style.cursor = 'pointer');
            group.on('mouseleave', () => stage.container().style.cursor = 'default');

            playerLayer.add(group);
            
            const cacheSize = r * 2 + 6;
            group.cache({
                pixelRatio: 3,
                x: -r - 3, y: -r - 3, width: cacheSize, height: cacheSize
            });
        }


        // åˆæœŸé…ç½®
        const playerPositions = ['LW', 'CF', 'RW', 'LD', 'RD'];
        const halfWidth = width / 2;
        const playerStep = halfWidth / 6; 
        const playerY = SIZES.benchTop * 0.6; 

        // èµ¤ãƒãƒ¼ãƒ 
        playerPositions.forEach((pos, index) => {
            const x = playerStep * (index + 0.8); 
            addPlayer(x, playerY, '#d62828', pos);
        });

        // é’ãƒãƒ¼ãƒ 
        playerPositions.forEach((pos, index) => {
            const x = halfWidth + (playerStep * (index + 0.8));
            addPlayer(x, playerY, '#0077b6', pos);
        });

        // ãƒ¬ãƒ•ã‚§ãƒªãƒ¼ & ãƒ‘ãƒƒã‚¯
        const refY = height - SIZES.toolbarArea + 20; 

        const leftRefs = ['L1', 'L2'];
        leftRefs.forEach((pos, index) => {
            const x = width * (0.08 + (index * 0.08)); 
            addPlayer(x, refY, '#444444', pos);
        });

        const rightRefs = ['R1', 'R2'];
        rightRefs.forEach((pos, index) => {
            const x = width * (0.84 + (index * 0.08));
            addPlayer(x, refY, '#444444', pos);
        });
        
        addPuck(startX + rinkWidth / 2, startY + rinkHeight / 2);
        addPuck(width * 0.5, refY);


        // --- 4. ãƒ„ãƒ¼ãƒ«å‹•ä½œ ---
        let isPaint = false;
        let mode = 'drag'; 
        let lastLine;

        const modes = ['drag', 'pen', 'eraser'];
        modes.forEach(m => {
            document.getElementById(`mode-${m}`).addEventListener('click', () => {
                mode = m;
                updateButtons();
                const isDraggable = (mode === 'drag');
                playerLayer.find('Group').forEach(g => g.draggable(isDraggable));
            });
        });

        function updateButtons() {
            modes.forEach(m => {
                const btn = document.getElementById(`mode-${m}`);
                btn.className = (mode === m) ? 'active' : '';
            });
        }

        stage.on('mousedown touchstart', function (e) {
            if (mode === 'drag') return;
            isPaint = true;
            const pos = stage.getPointerPosition();
            
            const penWidth = mode === 'pen' ? SIZES.lineThick : SIZES.playerRadius * 1.5;
            
            lastLine = new Konva.Line({
                stroke: mode === 'pen' ? 'black' : '#222',
                strokeWidth: penWidth,
                globalCompositeOperation: mode === 'pen' ? 'source-over' : 'destination-out',
                points: [pos.x, pos.y],
                lineCap: 'round',
                lineJoin: 'round',
                tension: 0.5,
                listening: false 
            });
            drawingLayer.add(lastLine);
        });

        stage.on('mouseup touchend', function () {
            isPaint = false;
        });

        stage.on('mousemove touchmove', function (e) {
            if (!isPaint || mode === 'drag') return;
            e.evt.preventDefault();
            const pos = stage.getPointerPosition();
            const newPoints = lastLine.points().concat([pos.x, pos.y]);
            lastLine.points(newPoints);
        });

        document.getElementById('clear-btn').addEventListener('click', function() {
            drawingLayer.destroyChildren();
            drawingLayer.batchDraw();
        });

        // ç”»é¢å›è»¢æ™‚ã®ãƒªãƒ­ãƒ¼ãƒ‰
        window.addEventListener("resize", function() {
            if (Math.abs(window.innerWidth - width) > 100) {
                location.reload();
            }
        });

        // â˜…â˜…â˜… ã‚ªãƒ•ãƒ©ã‚¤ãƒ³æ©Ÿèƒ½(Service Worker)ã®ç™»éŒ² â˜…â˜…â˜…
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', function() {
                navigator.serviceWorker.register('sw.js').then(function(registration) {
                    console.log('ServiceWorker registration successful');
                }, function(err) {
                    console.log('ServiceWorker registration failed: ', err);
                });
            });
        }
    </script>
</body>
</html>
